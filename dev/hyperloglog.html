<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>HyperLogLog · Probably.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Probably.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="home.html">Home</a></li><li class="current"><a class="toctext" href="hyperloglog.html">HyperLogLog</a><ul class="internal"><li><a class="toctext" href="#What-it-is-1">What it is</a></li><li><a class="toctext" href="#Usage-example-1">Usage example</a></li><li><a class="toctext" href="#Interface-1">Interface</a></li></ul></li><li><a class="toctext" href="countmin.html">Count-min sketch</a></li><li><a class="toctext" href="cuckoo.html">Cuckoo filter</a></li><li><a class="toctext" href="bloom.html">Bloom filter</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="hyperloglog.html">HyperLogLog</a></li></ul><a class="edit-page" href="https://github.com/jakobnissen/Probably.jl/blob/master/docs/src/hyperloglog.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>HyperLogLog</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="HyperLogLog-1" href="#HyperLogLog-1">HyperLogLog</a></h1><p>_References: Original algorithm: Flajolet, Fusy, Gandouet &amp; Meunier: &quot;Hyperloglog: The analysis of a near-optimal cardinality estimation algorithm&quot;.</p><p>With some of the modifications from: Heule, Nunkesser &amp; Hall: &quot;HyperLogLog in practice: Algorithmic engineering of a state of the art cardinality estimation algorithm&quot;._</p><hr/><h2><a class="nav-anchor" id="What-it-is-1" href="#What-it-is-1">What it is</a></h2><p>An HyperLogLog is a very memory-efficient datastructure that keeps track of approximately how many distinct, hashable elements it&#39;s seen. A default HLL uses 16 KiB of memory and can return reliable estimates of up to some very large cardinality (on the order of 2^59 distinct elements).</p><p>This estimate of cardinality has a median error of 0.5 %, and a 99 % chance of having an error less than 2.5 %, when the cardinality estimate is &gt;1024. To accurately keep track of datasets smaller than 1024, use another datastructure like a <code>Set</code>.</p><p>This implementation is not optimally memory-efficient, but it is fast. More advanced tricks can be found in the Heule et al. paper linked above, which increases accuracy and lowers memory usage for small N.</p><p>The HLLs are not guaranteed to be threadsafe. To parallelize this implementation of HLL, each process/thread must operate on independent HLLs. These can then be efficiently merged using <code>union</code> or <code>union!</code> (or <code>∪</code>). This is much faster than using atomic operations.</p><h2><a class="nav-anchor" id="Usage-example-1" href="#Usage-example-1">Usage example</a></h2><p>In this example, let&#39;s say I&#39;m given 133 million <a href="https://en.wikipedia.org/wiki/FASTQ_format">fastq-sequences</a> from a large sequencing project of Neanderthal bones. 133 million reads sounds like a lot, so, I&#39;m worried that the lab folk went a little overboard on the PCR and the same reads are present in many copies. Hence, I want to know how many unique reads there are. I don&#39;t care that the HyperLogLog doesn&#39;t fit in the cache, so I&#39;ll crank the <code>P</code> parameter up to 18 and spend the 256 KiB memory to maximize accuracy:</p><pre><code class="language-none">hll = HyperLogLog{18}()
reader = FASTQ.Reader(open(&quot;huge_file.fastq&quot;, &quot;r&quot;))
for record in reader
    seq = sequence(record) # we want a hashable DNA sequence    
    push!(hll, seq)
end
println(&quot;Number of distinct FASTQ-sequences: &quot;, length(hll))</code></pre><h2><a class="nav-anchor" id="Interface-1" href="#Interface-1">Interface</a></h2><h3><a class="nav-anchor" id="Construction-1" href="#Construction-1">Construction</a></h3><p>The accuracy of a HLL depends on its <code>P</code> parameter. You can construct a HLL with its <code>P</code> parameter directly:</p><pre><code class="language-none">julia&gt; hll = HyperLogLog{14}()
HyperLogLog{14}()</code></pre><p>A P-value of 14 is considered default, so if you don&#39;t pass the parameter, 14 is assumed as default:</p><pre><code class="language-none">julia&gt; HyperLogLog{14}() == HyperLogLog()
true</code></pre><h3><a class="nav-anchor" id="Central-functions-1" href="#Central-functions-1">Central functions</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.push!-Tuple{HyperLogLog,Any}" href="#Base.push!-Tuple{HyperLogLog,Any}"><code>Base.push!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">push!(hll::HyperLogLog, items...)</code></pre><p>Add each item to the HLL. This has no effect if the HLL has seen the items before.</p><p><strong>Examples</strong></p><pre><code class="language-none">julia&gt; a = HyperLogLog{14}(); push!(a, 1,2,3,4,5,6,7,8,9); length(a)
9</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jakobnissen/Probably.jl/blob/53523c9647b2c11a2db25714e51db3e826529b4b/src/hyperloglog/hyperloglog.jl#L142-L152">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.length-Tuple{HyperLogLog}" href="#Base.length-Tuple{HyperLogLog}"><code>Base.length</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">length(hll::HyperLogLog{Precision})</code></pre><p>Estimate the number of distinct elements the HLL has seen. The error depends on the Precision parameter. This has low absolute rror when the estimate is small, and low relative error when the estimate is high.</p><p><strong>Examples</strong></p><pre><code class="language-none">julia&gt; a = HyperLogLog{14}(); push!(a, 1,2,3,4,5,6,7,8); length(a)
9</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jakobnissen/Probably.jl/blob/53523c9647b2c11a2db25714e51db3e826529b4b/src/hyperloglog/hyperloglog.jl#L202-L214">source</a></section><h3><a class="nav-anchor" id="Misc-functions-1" href="#Misc-functions-1">Misc functions</a></h3><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>HyperLogLog supports the following operations, which have no HyperLogLog-specific docstring because they behave as stated in the documentation in Base:</p></div></div><pre><code class="language-none">Base.copy!
Base.copy
Base.sizeof # This one includes the underlying array</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty-Tuple{HyperLogLog}" href="#Base.isempty-Tuple{HyperLogLog}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">isempty(x::HyperLogLog)</code></pre><p>Return <code>true</code> if the HLL has not seen any elements, <code>false</code> otherwise. This is guaranteed to be correct, and so can be <code>true</code> even when length(x) &gt; 0.</p><p><strong>Examples</strong></p><pre><code class="language-none">julia&gt; a = HyperLogLog{14}(); (length(a), isempty(a))
(1, true)

&gt;julia push!(a, 1); (length(a), isempty(a))
(1, false)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jakobnissen/Probably.jl/blob/53523c9647b2c11a2db25714e51db3e826529b4b/src/hyperloglog/hyperloglog.jl#L115-L129">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.empty!-Tuple{HyperLogLog}" href="#Base.empty!-Tuple{HyperLogLog}"><code>Base.empty!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">empty!(x::HyperLogLog)</code></pre><p>Reset the HLL to its beginning state (i.e. &quot;deleting&quot; all elements from the HLL), returning it.</p><p><strong>Examples</strong></p><pre><code class="language-none">julia&gt; empty!(a); length(a) # should return approximately 0
1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jakobnissen/Probably.jl/blob/53523c9647b2c11a2db25714e51db3e826529b4b/src/hyperloglog/hyperloglog.jl#L101-L112">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.union!-Union{Tuple{P}, Tuple{HyperLogLog{P},HyperLogLog{P}}} where P" href="#Base.union!-Union{Tuple{P}, Tuple{HyperLogLog{P},HyperLogLog{P}}} where P"><code>Base.union!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">union!(dest::HyperLogLog{P}, src::HyperLogLog{P})</code></pre><p>Overwrite <code>dest</code> with the same result as <code>union(dest, src)</code>, returning <code>dest</code>.</p><p><strong>Examples</strong></p><pre><code class="language-none">julia&gt; # length(c) ≥ length(b) is not guaranteed, but overwhelmingly likely
julia&gt; c = union!(a, b); c === a &amp;&amp; length(c) ≥ length(b)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jakobnissen/Probably.jl/blob/53523c9647b2c11a2db25714e51db3e826529b4b/src/hyperloglog/hyperloglog.jl#L56-L67">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.union-Union{Tuple{P}, Tuple{HyperLogLog{P},HyperLogLog{P}}} where P" href="#Base.union-Union{Tuple{P}, Tuple{HyperLogLog{P},HyperLogLog{P}}} where P"><code>Base.union</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">union(x::HyperLogLog{P}, y::HyperLogLog{P})</code></pre><p>Create a new HLL identical to an HLL which has seen the union of the elements <code>x</code> and <code>y</code> has seen.</p><p><strong>Examples</strong></p><pre><code class="language-none">julia&gt; # That c is longer than a or b is not guaranteed, but overwhelmingly likely
julia&gt; c = union(a, b); length(c) ≥ length(a) &amp;&amp; length(c) ≥ length(b)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jakobnissen/Probably.jl/blob/53523c9647b2c11a2db25714e51db3e826529b4b/src/hyperloglog/hyperloglog.jl#L76-L88">source</a></section><footer><hr/><a class="previous" href="home.html"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="countmin.html"><span class="direction">Next</span><span class="title">Count-min sketch</span></a></footer></article></body></html>
